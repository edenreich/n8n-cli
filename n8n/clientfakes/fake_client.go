// Code generated by counterfeiter. DO NOT EDIT.
package clientfakes

import (
	"sync"

	"github.com/edenreich/n8n-cli/n8n"
)

type FakeClientInterface struct {
	ActivateWorkflowStub        func(string) (*n8n.Workflow, error)
	activateWorkflowMutex       sync.RWMutex
	activateWorkflowArgsForCall []struct {
		arg1 string
	}
	activateWorkflowReturns struct {
		result1 *n8n.Workflow
		result2 error
	}
	activateWorkflowReturnsOnCall map[int]struct {
		result1 *n8n.Workflow
		result2 error
	}
	CreateTagStub        func(string) (*n8n.Tag, error)
	createTagMutex       sync.RWMutex
	createTagArgsForCall []struct {
		arg1 string
	}
	createTagReturns struct {
		result1 *n8n.Tag
		result2 error
	}
	createTagReturnsOnCall map[int]struct {
		result1 *n8n.Tag
		result2 error
	}
	CreateWorkflowStub        func(*n8n.Workflow) (*n8n.Workflow, error)
	createWorkflowMutex       sync.RWMutex
	createWorkflowArgsForCall []struct {
		arg1 *n8n.Workflow
	}
	createWorkflowReturns struct {
		result1 *n8n.Workflow
		result2 error
	}
	createWorkflowReturnsOnCall map[int]struct {
		result1 *n8n.Workflow
		result2 error
	}
	DeactivateWorkflowStub        func(string) (*n8n.Workflow, error)
	deactivateWorkflowMutex       sync.RWMutex
	deactivateWorkflowArgsForCall []struct {
		arg1 string
	}
	deactivateWorkflowReturns struct {
		result1 *n8n.Workflow
		result2 error
	}
	deactivateWorkflowReturnsOnCall map[int]struct {
		result1 *n8n.Workflow
		result2 error
	}
	DeleteWorkflowStub        func(string) error
	deleteWorkflowMutex       sync.RWMutex
	deleteWorkflowArgsForCall []struct {
		arg1 string
	}
	deleteWorkflowReturns struct {
		result1 error
	}
	deleteWorkflowReturnsOnCall map[int]struct {
		result1 error
	}
	GetExecutionByIdStub        func(string, bool) (*n8n.Execution, error)
	getExecutionByIdMutex       sync.RWMutex
	getExecutionByIdArgsForCall []struct {
		arg1 string
		arg2 bool
	}
	getExecutionByIdReturns struct {
		result1 *n8n.Execution
		result2 error
	}
	getExecutionByIdReturnsOnCall map[int]struct {
		result1 *n8n.Execution
		result2 error
	}
	GetExecutionsStub        func(string, bool, string, int, string) (*n8n.ExecutionList, error)
	getExecutionsMutex       sync.RWMutex
	getExecutionsArgsForCall []struct {
		arg1 string
		arg2 bool
		arg3 string
		arg4 int
		arg5 string
	}
	getExecutionsReturns struct {
		result1 *n8n.ExecutionList
		result2 error
	}
	getExecutionsReturnsOnCall map[int]struct {
		result1 *n8n.ExecutionList
		result2 error
	}
	GetTagsStub        func() (*n8n.TagList, error)
	getTagsMutex       sync.RWMutex
	getTagsArgsForCall []struct {
	}
	getTagsReturns struct {
		result1 *n8n.TagList
		result2 error
	}
	getTagsReturnsOnCall map[int]struct {
		result1 *n8n.TagList
		result2 error
	}
	GetWorkflowStub        func(string) (*n8n.Workflow, error)
	getWorkflowMutex       sync.RWMutex
	getWorkflowArgsForCall []struct {
		arg1 string
	}
	getWorkflowReturns struct {
		result1 *n8n.Workflow
		result2 error
	}
	getWorkflowReturnsOnCall map[int]struct {
		result1 *n8n.Workflow
		result2 error
	}
	GetWorkflowTagsStub        func(string) (n8n.WorkflowTags, error)
	getWorkflowTagsMutex       sync.RWMutex
	getWorkflowTagsArgsForCall []struct {
		arg1 string
	}
	getWorkflowTagsReturns struct {
		result1 n8n.WorkflowTags
		result2 error
	}
	getWorkflowTagsReturnsOnCall map[int]struct {
		result1 n8n.WorkflowTags
		result2 error
	}
	GetWorkflowsStub        func() (*n8n.WorkflowList, error)
	getWorkflowsMutex       sync.RWMutex
	getWorkflowsArgsForCall []struct {
	}
	getWorkflowsReturns struct {
		result1 *n8n.WorkflowList
		result2 error
	}
	getWorkflowsReturnsOnCall map[int]struct {
		result1 *n8n.WorkflowList
		result2 error
	}
	UpdateWorkflowStub        func(string, *n8n.Workflow) (*n8n.Workflow, error)
	updateWorkflowMutex       sync.RWMutex
	updateWorkflowArgsForCall []struct {
		arg1 string
		arg2 *n8n.Workflow
	}
	updateWorkflowReturns struct {
		result1 *n8n.Workflow
		result2 error
	}
	updateWorkflowReturnsOnCall map[int]struct {
		result1 *n8n.Workflow
		result2 error
	}
	UpdateWorkflowTagsStub        func(string, n8n.TagIds) (n8n.WorkflowTags, error)
	updateWorkflowTagsMutex       sync.RWMutex
	updateWorkflowTagsArgsForCall []struct {
		arg1 string
		arg2 n8n.TagIds
	}
	updateWorkflowTagsReturns struct {
		result1 n8n.WorkflowTags
		result2 error
	}
	updateWorkflowTagsReturnsOnCall map[int]struct {
		result1 n8n.WorkflowTags
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeClientInterface) ActivateWorkflow(arg1 string) (*n8n.Workflow, error) {
	fake.activateWorkflowMutex.Lock()
	ret, specificReturn := fake.activateWorkflowReturnsOnCall[len(fake.activateWorkflowArgsForCall)]
	fake.activateWorkflowArgsForCall = append(fake.activateWorkflowArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ActivateWorkflowStub
	fakeReturns := fake.activateWorkflowReturns
	fake.recordInvocation("ActivateWorkflow", []interface{}{arg1})
	fake.activateWorkflowMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClientInterface) ActivateWorkflowCallCount() int {
	fake.activateWorkflowMutex.RLock()
	defer fake.activateWorkflowMutex.RUnlock()
	return len(fake.activateWorkflowArgsForCall)
}

func (fake *FakeClientInterface) ActivateWorkflowCalls(stub func(string) (*n8n.Workflow, error)) {
	fake.activateWorkflowMutex.Lock()
	defer fake.activateWorkflowMutex.Unlock()
	fake.ActivateWorkflowStub = stub
}

func (fake *FakeClientInterface) ActivateWorkflowArgsForCall(i int) string {
	fake.activateWorkflowMutex.RLock()
	defer fake.activateWorkflowMutex.RUnlock()
	argsForCall := fake.activateWorkflowArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClientInterface) ActivateWorkflowReturns(result1 *n8n.Workflow, result2 error) {
	fake.activateWorkflowMutex.Lock()
	defer fake.activateWorkflowMutex.Unlock()
	fake.ActivateWorkflowStub = nil
	fake.activateWorkflowReturns = struct {
		result1 *n8n.Workflow
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) ActivateWorkflowReturnsOnCall(i int, result1 *n8n.Workflow, result2 error) {
	fake.activateWorkflowMutex.Lock()
	defer fake.activateWorkflowMutex.Unlock()
	fake.ActivateWorkflowStub = nil
	if fake.activateWorkflowReturnsOnCall == nil {
		fake.activateWorkflowReturnsOnCall = make(map[int]struct {
			result1 *n8n.Workflow
			result2 error
		})
	}
	fake.activateWorkflowReturnsOnCall[i] = struct {
		result1 *n8n.Workflow
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) CreateTag(arg1 string) (*n8n.Tag, error) {
	fake.createTagMutex.Lock()
	ret, specificReturn := fake.createTagReturnsOnCall[len(fake.createTagArgsForCall)]
	fake.createTagArgsForCall = append(fake.createTagArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.CreateTagStub
	fakeReturns := fake.createTagReturns
	fake.recordInvocation("CreateTag", []interface{}{arg1})
	fake.createTagMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClientInterface) CreateTagCallCount() int {
	fake.createTagMutex.RLock()
	defer fake.createTagMutex.RUnlock()
	return len(fake.createTagArgsForCall)
}

func (fake *FakeClientInterface) CreateTagCalls(stub func(string) (*n8n.Tag, error)) {
	fake.createTagMutex.Lock()
	defer fake.createTagMutex.Unlock()
	fake.CreateTagStub = stub
}

func (fake *FakeClientInterface) CreateTagArgsForCall(i int) string {
	fake.createTagMutex.RLock()
	defer fake.createTagMutex.RUnlock()
	argsForCall := fake.createTagArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClientInterface) CreateTagReturns(result1 *n8n.Tag, result2 error) {
	fake.createTagMutex.Lock()
	defer fake.createTagMutex.Unlock()
	fake.CreateTagStub = nil
	fake.createTagReturns = struct {
		result1 *n8n.Tag
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) CreateTagReturnsOnCall(i int, result1 *n8n.Tag, result2 error) {
	fake.createTagMutex.Lock()
	defer fake.createTagMutex.Unlock()
	fake.CreateTagStub = nil
	if fake.createTagReturnsOnCall == nil {
		fake.createTagReturnsOnCall = make(map[int]struct {
			result1 *n8n.Tag
			result2 error
		})
	}
	fake.createTagReturnsOnCall[i] = struct {
		result1 *n8n.Tag
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) CreateWorkflow(arg1 *n8n.Workflow) (*n8n.Workflow, error) {
	fake.createWorkflowMutex.Lock()
	ret, specificReturn := fake.createWorkflowReturnsOnCall[len(fake.createWorkflowArgsForCall)]
	fake.createWorkflowArgsForCall = append(fake.createWorkflowArgsForCall, struct {
		arg1 *n8n.Workflow
	}{arg1})
	stub := fake.CreateWorkflowStub
	fakeReturns := fake.createWorkflowReturns
	fake.recordInvocation("CreateWorkflow", []interface{}{arg1})
	fake.createWorkflowMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClientInterface) CreateWorkflowCallCount() int {
	fake.createWorkflowMutex.RLock()
	defer fake.createWorkflowMutex.RUnlock()
	return len(fake.createWorkflowArgsForCall)
}

func (fake *FakeClientInterface) CreateWorkflowCalls(stub func(*n8n.Workflow) (*n8n.Workflow, error)) {
	fake.createWorkflowMutex.Lock()
	defer fake.createWorkflowMutex.Unlock()
	fake.CreateWorkflowStub = stub
}

func (fake *FakeClientInterface) CreateWorkflowArgsForCall(i int) *n8n.Workflow {
	fake.createWorkflowMutex.RLock()
	defer fake.createWorkflowMutex.RUnlock()
	argsForCall := fake.createWorkflowArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClientInterface) CreateWorkflowReturns(result1 *n8n.Workflow, result2 error) {
	fake.createWorkflowMutex.Lock()
	defer fake.createWorkflowMutex.Unlock()
	fake.CreateWorkflowStub = nil
	fake.createWorkflowReturns = struct {
		result1 *n8n.Workflow
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) CreateWorkflowReturnsOnCall(i int, result1 *n8n.Workflow, result2 error) {
	fake.createWorkflowMutex.Lock()
	defer fake.createWorkflowMutex.Unlock()
	fake.CreateWorkflowStub = nil
	if fake.createWorkflowReturnsOnCall == nil {
		fake.createWorkflowReturnsOnCall = make(map[int]struct {
			result1 *n8n.Workflow
			result2 error
		})
	}
	fake.createWorkflowReturnsOnCall[i] = struct {
		result1 *n8n.Workflow
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) DeactivateWorkflow(arg1 string) (*n8n.Workflow, error) {
	fake.deactivateWorkflowMutex.Lock()
	ret, specificReturn := fake.deactivateWorkflowReturnsOnCall[len(fake.deactivateWorkflowArgsForCall)]
	fake.deactivateWorkflowArgsForCall = append(fake.deactivateWorkflowArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DeactivateWorkflowStub
	fakeReturns := fake.deactivateWorkflowReturns
	fake.recordInvocation("DeactivateWorkflow", []interface{}{arg1})
	fake.deactivateWorkflowMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClientInterface) DeactivateWorkflowCallCount() int {
	fake.deactivateWorkflowMutex.RLock()
	defer fake.deactivateWorkflowMutex.RUnlock()
	return len(fake.deactivateWorkflowArgsForCall)
}

func (fake *FakeClientInterface) DeactivateWorkflowCalls(stub func(string) (*n8n.Workflow, error)) {
	fake.deactivateWorkflowMutex.Lock()
	defer fake.deactivateWorkflowMutex.Unlock()
	fake.DeactivateWorkflowStub = stub
}

func (fake *FakeClientInterface) DeactivateWorkflowArgsForCall(i int) string {
	fake.deactivateWorkflowMutex.RLock()
	defer fake.deactivateWorkflowMutex.RUnlock()
	argsForCall := fake.deactivateWorkflowArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClientInterface) DeactivateWorkflowReturns(result1 *n8n.Workflow, result2 error) {
	fake.deactivateWorkflowMutex.Lock()
	defer fake.deactivateWorkflowMutex.Unlock()
	fake.DeactivateWorkflowStub = nil
	fake.deactivateWorkflowReturns = struct {
		result1 *n8n.Workflow
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) DeactivateWorkflowReturnsOnCall(i int, result1 *n8n.Workflow, result2 error) {
	fake.deactivateWorkflowMutex.Lock()
	defer fake.deactivateWorkflowMutex.Unlock()
	fake.DeactivateWorkflowStub = nil
	if fake.deactivateWorkflowReturnsOnCall == nil {
		fake.deactivateWorkflowReturnsOnCall = make(map[int]struct {
			result1 *n8n.Workflow
			result2 error
		})
	}
	fake.deactivateWorkflowReturnsOnCall[i] = struct {
		result1 *n8n.Workflow
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) DeleteWorkflow(arg1 string) error {
	fake.deleteWorkflowMutex.Lock()
	ret, specificReturn := fake.deleteWorkflowReturnsOnCall[len(fake.deleteWorkflowArgsForCall)]
	fake.deleteWorkflowArgsForCall = append(fake.deleteWorkflowArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DeleteWorkflowStub
	fakeReturns := fake.deleteWorkflowReturns
	fake.recordInvocation("DeleteWorkflow", []interface{}{arg1})
	fake.deleteWorkflowMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClientInterface) DeleteWorkflowCallCount() int {
	fake.deleteWorkflowMutex.RLock()
	defer fake.deleteWorkflowMutex.RUnlock()
	return len(fake.deleteWorkflowArgsForCall)
}

func (fake *FakeClientInterface) DeleteWorkflowCalls(stub func(string) error) {
	fake.deleteWorkflowMutex.Lock()
	defer fake.deleteWorkflowMutex.Unlock()
	fake.DeleteWorkflowStub = stub
}

func (fake *FakeClientInterface) DeleteWorkflowArgsForCall(i int) string {
	fake.deleteWorkflowMutex.RLock()
	defer fake.deleteWorkflowMutex.RUnlock()
	argsForCall := fake.deleteWorkflowArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClientInterface) DeleteWorkflowReturns(result1 error) {
	fake.deleteWorkflowMutex.Lock()
	defer fake.deleteWorkflowMutex.Unlock()
	fake.DeleteWorkflowStub = nil
	fake.deleteWorkflowReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClientInterface) DeleteWorkflowReturnsOnCall(i int, result1 error) {
	fake.deleteWorkflowMutex.Lock()
	defer fake.deleteWorkflowMutex.Unlock()
	fake.DeleteWorkflowStub = nil
	if fake.deleteWorkflowReturnsOnCall == nil {
		fake.deleteWorkflowReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteWorkflowReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClientInterface) GetExecutionById(arg1 string, arg2 bool) (*n8n.Execution, error) {
	fake.getExecutionByIdMutex.Lock()
	ret, specificReturn := fake.getExecutionByIdReturnsOnCall[len(fake.getExecutionByIdArgsForCall)]
	fake.getExecutionByIdArgsForCall = append(fake.getExecutionByIdArgsForCall, struct {
		arg1 string
		arg2 bool
	}{arg1, arg2})
	stub := fake.GetExecutionByIdStub
	fakeReturns := fake.getExecutionByIdReturns
	fake.recordInvocation("GetExecutionById", []interface{}{arg1, arg2})
	fake.getExecutionByIdMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClientInterface) GetExecutionByIdCallCount() int {
	fake.getExecutionByIdMutex.RLock()
	defer fake.getExecutionByIdMutex.RUnlock()
	return len(fake.getExecutionByIdArgsForCall)
}

func (fake *FakeClientInterface) GetExecutionByIdCalls(stub func(string, bool) (*n8n.Execution, error)) {
	fake.getExecutionByIdMutex.Lock()
	defer fake.getExecutionByIdMutex.Unlock()
	fake.GetExecutionByIdStub = stub
}

func (fake *FakeClientInterface) GetExecutionByIdArgsForCall(i int) (string, bool) {
	fake.getExecutionByIdMutex.RLock()
	defer fake.getExecutionByIdMutex.RUnlock()
	argsForCall := fake.getExecutionByIdArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClientInterface) GetExecutionByIdReturns(result1 *n8n.Execution, result2 error) {
	fake.getExecutionByIdMutex.Lock()
	defer fake.getExecutionByIdMutex.Unlock()
	fake.GetExecutionByIdStub = nil
	fake.getExecutionByIdReturns = struct {
		result1 *n8n.Execution
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) GetExecutionByIdReturnsOnCall(i int, result1 *n8n.Execution, result2 error) {
	fake.getExecutionByIdMutex.Lock()
	defer fake.getExecutionByIdMutex.Unlock()
	fake.GetExecutionByIdStub = nil
	if fake.getExecutionByIdReturnsOnCall == nil {
		fake.getExecutionByIdReturnsOnCall = make(map[int]struct {
			result1 *n8n.Execution
			result2 error
		})
	}
	fake.getExecutionByIdReturnsOnCall[i] = struct {
		result1 *n8n.Execution
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) GetExecutions(arg1 string, arg2 bool, arg3 string, arg4 int, arg5 string) (*n8n.ExecutionList, error) {
	fake.getExecutionsMutex.Lock()
	ret, specificReturn := fake.getExecutionsReturnsOnCall[len(fake.getExecutionsArgsForCall)]
	fake.getExecutionsArgsForCall = append(fake.getExecutionsArgsForCall, struct {
		arg1 string
		arg2 bool
		arg3 string
		arg4 int
		arg5 string
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.GetExecutionsStub
	fakeReturns := fake.getExecutionsReturns
	fake.recordInvocation("GetExecutions", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.getExecutionsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClientInterface) GetExecutionsCallCount() int {
	fake.getExecutionsMutex.RLock()
	defer fake.getExecutionsMutex.RUnlock()
	return len(fake.getExecutionsArgsForCall)
}

func (fake *FakeClientInterface) GetExecutionsCalls(stub func(string, bool, string, int, string) (*n8n.ExecutionList, error)) {
	fake.getExecutionsMutex.Lock()
	defer fake.getExecutionsMutex.Unlock()
	fake.GetExecutionsStub = stub
}

func (fake *FakeClientInterface) GetExecutionsArgsForCall(i int) (string, bool, string, int, string) {
	fake.getExecutionsMutex.RLock()
	defer fake.getExecutionsMutex.RUnlock()
	argsForCall := fake.getExecutionsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeClientInterface) GetExecutionsReturns(result1 *n8n.ExecutionList, result2 error) {
	fake.getExecutionsMutex.Lock()
	defer fake.getExecutionsMutex.Unlock()
	fake.GetExecutionsStub = nil
	fake.getExecutionsReturns = struct {
		result1 *n8n.ExecutionList
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) GetExecutionsReturnsOnCall(i int, result1 *n8n.ExecutionList, result2 error) {
	fake.getExecutionsMutex.Lock()
	defer fake.getExecutionsMutex.Unlock()
	fake.GetExecutionsStub = nil
	if fake.getExecutionsReturnsOnCall == nil {
		fake.getExecutionsReturnsOnCall = make(map[int]struct {
			result1 *n8n.ExecutionList
			result2 error
		})
	}
	fake.getExecutionsReturnsOnCall[i] = struct {
		result1 *n8n.ExecutionList
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) GetTags() (*n8n.TagList, error) {
	fake.getTagsMutex.Lock()
	ret, specificReturn := fake.getTagsReturnsOnCall[len(fake.getTagsArgsForCall)]
	fake.getTagsArgsForCall = append(fake.getTagsArgsForCall, struct {
	}{})
	stub := fake.GetTagsStub
	fakeReturns := fake.getTagsReturns
	fake.recordInvocation("GetTags", []interface{}{})
	fake.getTagsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClientInterface) GetTagsCallCount() int {
	fake.getTagsMutex.RLock()
	defer fake.getTagsMutex.RUnlock()
	return len(fake.getTagsArgsForCall)
}

func (fake *FakeClientInterface) GetTagsCalls(stub func() (*n8n.TagList, error)) {
	fake.getTagsMutex.Lock()
	defer fake.getTagsMutex.Unlock()
	fake.GetTagsStub = stub
}

func (fake *FakeClientInterface) GetTagsReturns(result1 *n8n.TagList, result2 error) {
	fake.getTagsMutex.Lock()
	defer fake.getTagsMutex.Unlock()
	fake.GetTagsStub = nil
	fake.getTagsReturns = struct {
		result1 *n8n.TagList
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) GetTagsReturnsOnCall(i int, result1 *n8n.TagList, result2 error) {
	fake.getTagsMutex.Lock()
	defer fake.getTagsMutex.Unlock()
	fake.GetTagsStub = nil
	if fake.getTagsReturnsOnCall == nil {
		fake.getTagsReturnsOnCall = make(map[int]struct {
			result1 *n8n.TagList
			result2 error
		})
	}
	fake.getTagsReturnsOnCall[i] = struct {
		result1 *n8n.TagList
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) GetWorkflow(arg1 string) (*n8n.Workflow, error) {
	fake.getWorkflowMutex.Lock()
	ret, specificReturn := fake.getWorkflowReturnsOnCall[len(fake.getWorkflowArgsForCall)]
	fake.getWorkflowArgsForCall = append(fake.getWorkflowArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetWorkflowStub
	fakeReturns := fake.getWorkflowReturns
	fake.recordInvocation("GetWorkflow", []interface{}{arg1})
	fake.getWorkflowMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClientInterface) GetWorkflowCallCount() int {
	fake.getWorkflowMutex.RLock()
	defer fake.getWorkflowMutex.RUnlock()
	return len(fake.getWorkflowArgsForCall)
}

func (fake *FakeClientInterface) GetWorkflowCalls(stub func(string) (*n8n.Workflow, error)) {
	fake.getWorkflowMutex.Lock()
	defer fake.getWorkflowMutex.Unlock()
	fake.GetWorkflowStub = stub
}

func (fake *FakeClientInterface) GetWorkflowArgsForCall(i int) string {
	fake.getWorkflowMutex.RLock()
	defer fake.getWorkflowMutex.RUnlock()
	argsForCall := fake.getWorkflowArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClientInterface) GetWorkflowReturns(result1 *n8n.Workflow, result2 error) {
	fake.getWorkflowMutex.Lock()
	defer fake.getWorkflowMutex.Unlock()
	fake.GetWorkflowStub = nil
	fake.getWorkflowReturns = struct {
		result1 *n8n.Workflow
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) GetWorkflowReturnsOnCall(i int, result1 *n8n.Workflow, result2 error) {
	fake.getWorkflowMutex.Lock()
	defer fake.getWorkflowMutex.Unlock()
	fake.GetWorkflowStub = nil
	if fake.getWorkflowReturnsOnCall == nil {
		fake.getWorkflowReturnsOnCall = make(map[int]struct {
			result1 *n8n.Workflow
			result2 error
		})
	}
	fake.getWorkflowReturnsOnCall[i] = struct {
		result1 *n8n.Workflow
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) GetWorkflowTags(arg1 string) (n8n.WorkflowTags, error) {
	fake.getWorkflowTagsMutex.Lock()
	ret, specificReturn := fake.getWorkflowTagsReturnsOnCall[len(fake.getWorkflowTagsArgsForCall)]
	fake.getWorkflowTagsArgsForCall = append(fake.getWorkflowTagsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetWorkflowTagsStub
	fakeReturns := fake.getWorkflowTagsReturns
	fake.recordInvocation("GetWorkflowTags", []interface{}{arg1})
	fake.getWorkflowTagsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClientInterface) GetWorkflowTagsCallCount() int {
	fake.getWorkflowTagsMutex.RLock()
	defer fake.getWorkflowTagsMutex.RUnlock()
	return len(fake.getWorkflowTagsArgsForCall)
}

func (fake *FakeClientInterface) GetWorkflowTagsCalls(stub func(string) (n8n.WorkflowTags, error)) {
	fake.getWorkflowTagsMutex.Lock()
	defer fake.getWorkflowTagsMutex.Unlock()
	fake.GetWorkflowTagsStub = stub
}

func (fake *FakeClientInterface) GetWorkflowTagsArgsForCall(i int) string {
	fake.getWorkflowTagsMutex.RLock()
	defer fake.getWorkflowTagsMutex.RUnlock()
	argsForCall := fake.getWorkflowTagsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClientInterface) GetWorkflowTagsReturns(result1 n8n.WorkflowTags, result2 error) {
	fake.getWorkflowTagsMutex.Lock()
	defer fake.getWorkflowTagsMutex.Unlock()
	fake.GetWorkflowTagsStub = nil
	fake.getWorkflowTagsReturns = struct {
		result1 n8n.WorkflowTags
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) GetWorkflowTagsReturnsOnCall(i int, result1 n8n.WorkflowTags, result2 error) {
	fake.getWorkflowTagsMutex.Lock()
	defer fake.getWorkflowTagsMutex.Unlock()
	fake.GetWorkflowTagsStub = nil
	if fake.getWorkflowTagsReturnsOnCall == nil {
		fake.getWorkflowTagsReturnsOnCall = make(map[int]struct {
			result1 n8n.WorkflowTags
			result2 error
		})
	}
	fake.getWorkflowTagsReturnsOnCall[i] = struct {
		result1 n8n.WorkflowTags
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) GetWorkflows() (*n8n.WorkflowList, error) {
	fake.getWorkflowsMutex.Lock()
	ret, specificReturn := fake.getWorkflowsReturnsOnCall[len(fake.getWorkflowsArgsForCall)]
	fake.getWorkflowsArgsForCall = append(fake.getWorkflowsArgsForCall, struct {
	}{})
	stub := fake.GetWorkflowsStub
	fakeReturns := fake.getWorkflowsReturns
	fake.recordInvocation("GetWorkflows", []interface{}{})
	fake.getWorkflowsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClientInterface) GetWorkflowsCallCount() int {
	fake.getWorkflowsMutex.RLock()
	defer fake.getWorkflowsMutex.RUnlock()
	return len(fake.getWorkflowsArgsForCall)
}

func (fake *FakeClientInterface) GetWorkflowsCalls(stub func() (*n8n.WorkflowList, error)) {
	fake.getWorkflowsMutex.Lock()
	defer fake.getWorkflowsMutex.Unlock()
	fake.GetWorkflowsStub = stub
}

func (fake *FakeClientInterface) GetWorkflowsReturns(result1 *n8n.WorkflowList, result2 error) {
	fake.getWorkflowsMutex.Lock()
	defer fake.getWorkflowsMutex.Unlock()
	fake.GetWorkflowsStub = nil
	fake.getWorkflowsReturns = struct {
		result1 *n8n.WorkflowList
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) GetWorkflowsReturnsOnCall(i int, result1 *n8n.WorkflowList, result2 error) {
	fake.getWorkflowsMutex.Lock()
	defer fake.getWorkflowsMutex.Unlock()
	fake.GetWorkflowsStub = nil
	if fake.getWorkflowsReturnsOnCall == nil {
		fake.getWorkflowsReturnsOnCall = make(map[int]struct {
			result1 *n8n.WorkflowList
			result2 error
		})
	}
	fake.getWorkflowsReturnsOnCall[i] = struct {
		result1 *n8n.WorkflowList
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) UpdateWorkflow(arg1 string, arg2 *n8n.Workflow) (*n8n.Workflow, error) {
	fake.updateWorkflowMutex.Lock()
	ret, specificReturn := fake.updateWorkflowReturnsOnCall[len(fake.updateWorkflowArgsForCall)]
	fake.updateWorkflowArgsForCall = append(fake.updateWorkflowArgsForCall, struct {
		arg1 string
		arg2 *n8n.Workflow
	}{arg1, arg2})
	stub := fake.UpdateWorkflowStub
	fakeReturns := fake.updateWorkflowReturns
	fake.recordInvocation("UpdateWorkflow", []interface{}{arg1, arg2})
	fake.updateWorkflowMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClientInterface) UpdateWorkflowCallCount() int {
	fake.updateWorkflowMutex.RLock()
	defer fake.updateWorkflowMutex.RUnlock()
	return len(fake.updateWorkflowArgsForCall)
}

func (fake *FakeClientInterface) UpdateWorkflowCalls(stub func(string, *n8n.Workflow) (*n8n.Workflow, error)) {
	fake.updateWorkflowMutex.Lock()
	defer fake.updateWorkflowMutex.Unlock()
	fake.UpdateWorkflowStub = stub
}

func (fake *FakeClientInterface) UpdateWorkflowArgsForCall(i int) (string, *n8n.Workflow) {
	fake.updateWorkflowMutex.RLock()
	defer fake.updateWorkflowMutex.RUnlock()
	argsForCall := fake.updateWorkflowArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClientInterface) UpdateWorkflowReturns(result1 *n8n.Workflow, result2 error) {
	fake.updateWorkflowMutex.Lock()
	defer fake.updateWorkflowMutex.Unlock()
	fake.UpdateWorkflowStub = nil
	fake.updateWorkflowReturns = struct {
		result1 *n8n.Workflow
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) UpdateWorkflowReturnsOnCall(i int, result1 *n8n.Workflow, result2 error) {
	fake.updateWorkflowMutex.Lock()
	defer fake.updateWorkflowMutex.Unlock()
	fake.UpdateWorkflowStub = nil
	if fake.updateWorkflowReturnsOnCall == nil {
		fake.updateWorkflowReturnsOnCall = make(map[int]struct {
			result1 *n8n.Workflow
			result2 error
		})
	}
	fake.updateWorkflowReturnsOnCall[i] = struct {
		result1 *n8n.Workflow
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) UpdateWorkflowTags(arg1 string, arg2 n8n.TagIds) (n8n.WorkflowTags, error) {
	fake.updateWorkflowTagsMutex.Lock()
	ret, specificReturn := fake.updateWorkflowTagsReturnsOnCall[len(fake.updateWorkflowTagsArgsForCall)]
	fake.updateWorkflowTagsArgsForCall = append(fake.updateWorkflowTagsArgsForCall, struct {
		arg1 string
		arg2 n8n.TagIds
	}{arg1, arg2})
	stub := fake.UpdateWorkflowTagsStub
	fakeReturns := fake.updateWorkflowTagsReturns
	fake.recordInvocation("UpdateWorkflowTags", []interface{}{arg1, arg2})
	fake.updateWorkflowTagsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClientInterface) UpdateWorkflowTagsCallCount() int {
	fake.updateWorkflowTagsMutex.RLock()
	defer fake.updateWorkflowTagsMutex.RUnlock()
	return len(fake.updateWorkflowTagsArgsForCall)
}

func (fake *FakeClientInterface) UpdateWorkflowTagsCalls(stub func(string, n8n.TagIds) (n8n.WorkflowTags, error)) {
	fake.updateWorkflowTagsMutex.Lock()
	defer fake.updateWorkflowTagsMutex.Unlock()
	fake.UpdateWorkflowTagsStub = stub
}

func (fake *FakeClientInterface) UpdateWorkflowTagsArgsForCall(i int) (string, n8n.TagIds) {
	fake.updateWorkflowTagsMutex.RLock()
	defer fake.updateWorkflowTagsMutex.RUnlock()
	argsForCall := fake.updateWorkflowTagsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClientInterface) UpdateWorkflowTagsReturns(result1 n8n.WorkflowTags, result2 error) {
	fake.updateWorkflowTagsMutex.Lock()
	defer fake.updateWorkflowTagsMutex.Unlock()
	fake.UpdateWorkflowTagsStub = nil
	fake.updateWorkflowTagsReturns = struct {
		result1 n8n.WorkflowTags
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) UpdateWorkflowTagsReturnsOnCall(i int, result1 n8n.WorkflowTags, result2 error) {
	fake.updateWorkflowTagsMutex.Lock()
	defer fake.updateWorkflowTagsMutex.Unlock()
	fake.UpdateWorkflowTagsStub = nil
	if fake.updateWorkflowTagsReturnsOnCall == nil {
		fake.updateWorkflowTagsReturnsOnCall = make(map[int]struct {
			result1 n8n.WorkflowTags
			result2 error
		})
	}
	fake.updateWorkflowTagsReturnsOnCall[i] = struct {
		result1 n8n.WorkflowTags
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.activateWorkflowMutex.RLock()
	defer fake.activateWorkflowMutex.RUnlock()
	fake.createTagMutex.RLock()
	defer fake.createTagMutex.RUnlock()
	fake.createWorkflowMutex.RLock()
	defer fake.createWorkflowMutex.RUnlock()
	fake.deactivateWorkflowMutex.RLock()
	defer fake.deactivateWorkflowMutex.RUnlock()
	fake.deleteWorkflowMutex.RLock()
	defer fake.deleteWorkflowMutex.RUnlock()
	fake.getExecutionByIdMutex.RLock()
	defer fake.getExecutionByIdMutex.RUnlock()
	fake.getExecutionsMutex.RLock()
	defer fake.getExecutionsMutex.RUnlock()
	fake.getTagsMutex.RLock()
	defer fake.getTagsMutex.RUnlock()
	fake.getWorkflowMutex.RLock()
	defer fake.getWorkflowMutex.RUnlock()
	fake.getWorkflowTagsMutex.RLock()
	defer fake.getWorkflowTagsMutex.RUnlock()
	fake.getWorkflowsMutex.RLock()
	defer fake.getWorkflowsMutex.RUnlock()
	fake.updateWorkflowMutex.RLock()
	defer fake.updateWorkflowMutex.RUnlock()
	fake.updateWorkflowTagsMutex.RLock()
	defer fake.updateWorkflowTagsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeClientInterface) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ n8n.ClientInterface = new(FakeClientInterface)
